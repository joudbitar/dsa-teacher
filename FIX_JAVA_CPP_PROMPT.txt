üö® URGENT: Fix Progressive Unlocking for Java & C++ Templates

# THE PROBLEM

Go, Java, and C++ all have the same critical bug: they compile ALL test code at once, including locked tests that reference undefined methods. This forces users to implement everything at once, breaking incremental learning.

**Status:**
‚úÖ Go - FIXED (split into separate test files)
üî¥ Java - BROKEN (needs fix NOW)
üî¥ C++ - BROKEN (needs fix NOW)

**Example of the bug:**
```java
// Test02Push.java - Maven compiles this even when locked!
stack.push(10);  // ‚Üê ERROR if push() method doesn't exist yet!
```

# YOUR MISSION

Fix ALL Java and C++ templates (8 total) to support progressive unlocking using the SAME approach that fixed Go.

# PART 1: FIX JAVA TEMPLATES (4 templates)

## Java Fix Strategy

Split test files into separate files in tests/ directory, update TestRunner to compile only unlocked tests.

## Templates to Fix

1. template-dsa-stack-java
2. template-dsa-queue-java  
3. template-dsa-binary-search-java
4. template-dsa-min-heap-java

## Steps for EACH Java Template

### Step 1: Split Test Files

```bash
cd /Users/joudbitar/Code/Projects/dsa-templates/template-dsa-MODULE-java

# Create tests directory structure
mkdir -p tests

# Move test files to tests/ and rename to match pattern
# Example for Stack:
mv src/test/java/Test01CreateClass.java tests/Test01_CreateClass.java
mv src/test/java/Test02Push.java tests/Test02_Push.java
mv src/test/java/Test03Pop.java tests/Test03_Pop.java
mv src/test/java/Test04Peek.java tests/Test04_Peek.java
mv src/test/java/Test05Size.java tests/Test05_Size.java

# Keep TestRunner in src/test/java/ - it stays there
```

### Step 2: Create New TestRunner

Replace `src/test/java/TestRunner.java` with this pattern (adjust for each module):

```java
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import javax.tools.*;

public class TestRunner {
    
    static class TestCase {
        String subchallengeId;
        boolean passed;
        String message;
        
        TestCase(String subchallengeId, boolean passed, String message) {
            this.subchallengeId = subchallengeId;
            this.passed = passed;
            this.message = message;
        }
    }
    
    static class Report {
        String moduleId;
        String summary;
        boolean pass;
        List<TestCase> cases;
        int currentChallengeIndex;
        
        Report(String moduleId, String summary, boolean pass, List<TestCase> cases, int currentChallengeIndex) {
            this.moduleId = moduleId;
            this.summary = summary;
            this.pass = pass;
            this.cases = cases;
            this.currentChallengeIndex = currentChallengeIndex;
        }
    }
    
    static class Config {
        int currentChallengeIndex;
    }
    
    static int getCurrentChallengeIndex() {
        try (FileReader reader = new FileReader("dsa.config.json")) {
            Gson gson = new Gson();
            Config config = gson.fromJson(reader, Config.class);
            return config.currentChallengeIndex;
        } catch (Exception e) {
            return 0;
        }
    }
    
    public static void main(String[] args) throws Exception {
        // ADJUST THIS MAP FOR EACH MODULE
        Map<String, String> allTests = new LinkedHashMap<>();
        allTests.put("Test01_CreateClass", "create-class");
        allTests.put("Test02_Push", "push");
        allTests.put("Test03_Pop", "pop");
        allTests.put("Test04_Peek", "peek");
        allTests.put("Test05_Size", "size");
        
        int currentIndex = getCurrentChallengeIndex();
        List<Map.Entry<String, String>> testsList = new ArrayList<>(allTests.entrySet());
        List<Map.Entry<String, String>> testsToRun = testsList.subList(0, Math.min(currentIndex + 1, testsList.size()));
        int lockedCount = testsList.size() - testsToRun.size();
        
        System.out.println("Running tests for: MODULE_NAME");  // ADJUST
        System.out.println("Current challenge: " + (currentIndex + 1) + "/" + testsList.size());
        System.out.println();
        
        List<TestCase> results = new ArrayList<>();
        int passedCount = 0;
        
        // Copy only unlocked test files and compile them
        for (Map.Entry<String, String> entry : testsToRun) {
            String testFile = entry.getKey() + ".java";
            String slug = entry.getValue();
            
            try {
                // Copy test file from tests/ to src/test/java/
                Files.copy(
                    Paths.get("tests/" + testFile),
                    Paths.get("src/test/java/" + testFile),
                    StandardCopyOption.REPLACE_EXISTING
                );
                
                // Run Maven test for this specific test
                ProcessBuilder pb = new ProcessBuilder("mvn", "test", "-Dtest=" + entry.getKey());
                pb.redirectErrorStream(true);
                Process process = pb.start();
                
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                StringBuilder output = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
                
                int exitCode = process.waitFor();
                boolean passed = exitCode == 0;
                
                // Clean up copied file
                Files.deleteIfExists(Paths.get("src/test/java/" + testFile));
                
                if (passed) {
                    System.out.println("‚úì " + slug);
                    results.add(new TestCase(slug, true, null));
                    passedCount++;
                } else {
                    System.out.println("‚úó " + slug);
                    results.add(new TestCase(slug, false, "Test failed"));
                }
            } catch (Exception e) {
                System.out.println("‚úó " + slug);
                results.add(new TestCase(slug, false, e.getMessage()));
            }
        }
        
        for (int i = testsToRun.size(); i < testsList.size(); i++) {
            results.add(new TestCase(testsList.get(i).getValue(), false, "Challenge locked"));
        }
        
        String summary = passedCount + "/" + testsToRun.size() + " tests passed (" + lockedCount + " locked)";
        boolean pass = passedCount == testsToRun.size();
        Report report = new Report("MODULE_ID", summary, pass, results, currentIndex);  // ADJUST MODULE_ID
        
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(".dsa-report.json")) {
            gson.toJson(report, writer);
        }
        
        System.out.println("\nSummary: " + summary);
        System.exit(pass ? 0 : 1);
    }
}
```

### Step 3: Commit & Push

```bash
# Remove old test files from src/test/java (they're now in tests/)
# Keep only TestRunner.java in src/test/java/

git add -A
git commit -m "Fix Java progressive unlocking: split tests into separate files

- Split test classes into tests/ directory
- Updated TestRunner to compile only unlocked tests
- Prevents compilation errors from locked tests referencing undefined methods"
git push
```

## Specific Commands for Each Java Template

### Stack:
```bash
cd /Users/joudbitar/Code/Projects/dsa-templates/template-dsa-stack-java
mkdir -p tests
mv src/test/java/Test01CreateClass.java tests/Test01_CreateClass.java
mv src/test/java/Test02Push.java tests/Test02_Push.java
mv src/test/java/Test03Pop.java tests/Test03_Pop.java
mv src/test/java/Test04Peek.java tests/Test04_Peek.java
mv src/test/java/Test05Size.java tests/Test05_Size.java
# Create new TestRunner with moduleId="stack"
```

### Queue:
```bash
cd /Users/joudbitar/Code/Projects/dsa-templates/template-dsa-queue-java
mkdir -p tests
mv src/test/java/Test01CreateClass.java tests/Test01_CreateClass.java
mv src/test/java/Test02Enqueue.java tests/Test02_Enqueue.java
mv src/test/java/Test03Dequeue.java tests/Test03_Dequeue.java
mv src/test/java/Test04Front.java tests/Test04_Front.java
mv src/test/java/Test05Size.java tests/Test05_Size.java
# Create new TestRunner with moduleId="queue"
```

### Binary Search:
```bash
cd /Users/joudbitar/Code/Projects/dsa-templates/template-dsa-binary-search-java
mkdir -p tests
mv src/test/java/Test01EmptyArray.java tests/Test01_EmptyArray.java
mv src/test/java/Test02FoundIndex.java tests/Test02_FoundIndex.java
mv src/test/java/Test03NotFound.java tests/Test03_NotFound.java
mv src/test/java/Test04Bounds.java tests/Test04_Bounds.java
# Create new TestRunner with moduleId="binary-search"
```

### Min Heap:
```bash
cd /Users/joudbitar/Code/Projects/dsa-templates/template-dsa-min-heap-java
mkdir -p tests
mv src/test/java/Test01Insert.java tests/Test01_Insert.java
mv src/test/java/Test02HeapifyUp.java tests/Test02_HeapifyUp.java
mv src/test/java/Test03Peek.java tests/Test03_Peek.java
mv src/test/java/Test04Extract.java tests/Test04_Extract.java
mv src/test/java/Test05HeapifyDown.java tests/Test05_HeapifyDown.java
mv src/test/java/Test06Size.java tests/Test06_Size.java
# Create new TestRunner with moduleId="min-heap"
```

# PART 2: FIX C++ TEMPLATES (4 templates)

## C++ Fix Strategy

Same as Go: Split monolithic test file into separate files, compile only unlocked tests.

## Templates to Fix

1. template-dsa-stack-cpp
2. template-dsa-queue-cpp
3. template-dsa-binary-search-cpp
4. template-dsa-min-heap-cpp

## Steps for EACH C++ Template

### Step 1: Split Test File

Use this script to split test file:

```bash
cd /Users/joudbitar/Code/Projects/dsa-templates/template-dsa-MODULE-cpp/tests

# Read the monolithic test file and split by TEST(...) blocks
awk '
  BEGIN { 
    file_num = 1
    in_test = 0
  }
  /^\/\/ Test:/ {
    test_name = $0
    gsub(/^\/\/ Test: /, "", test_name)
    gsub(/ /, "_", test_name)
    next
  }
  /^TEST\(/ {
    if (out_file != "") close(out_file)
    out_file = sprintf("test_%02d_%s.cpp", file_num, tolower(test_name))
    file_num++
    print "#include <gtest/gtest.h>" > out_file
    print "#include \"MODULE.h\"\n" >> out_file  # ADJUST MODULE NAME
    in_test = 1
  }
  in_test {
    print >> out_file
    if (/^}$/ && NF == 1) {
      in_test = 0
    }
  }
' test_MODULE.cpp  # ADJUST
```

### Step 2: Update run.sh

Replace `tests/run.sh` with this pattern:

```bash
#!/bin/bash

MODULE_ID="stack"  # ADJUST

get_current_challenge_index() {
  if [ -f dsa.config.json ]; then
    python3 -c "import json; print(json.load(open('dsa.config.json'))['currentChallengeIndex'])" 2>/dev/null || echo "0"
  else
    echo "0"
  fi
}

currentIndex=$(get_current_challenge_index)
maxTests=$(ls tests/test_*.cpp 2>/dev/null | wc -l | tr -d ' ')
testsToRun=$((currentIndex + 1))

echo "Running tests for: $MODULE_ID"
echo "Current challenge: $testsToRun/$maxTests"
echo ""

# Compile only unlocked test files
test_files=""
for i in $(seq 1 $testsToRun); do
  file=$(printf "tests/test_%02d_*.cpp" $i)
  if ls $file 1> /dev/null 2>&1; then
    test_files="$test_files $file"
  fi
done

# Compile
g++ -std=c++17 $test_files -lgtest -lgtest_main -pthread -o test_runner 2>&1

if [ $? -ne 0 ]; then
  echo "‚úó Compilation failed"
  exit 1
fi

# Run tests
./test_runner

exit_code=$?
rm -f test_runner
exit $exit_code
```

### Step 3: Commit & Push

```bash
rm test_MODULE.cpp  # Remove old monolithic file
git add -A
git commit -m "Fix C++ progressive unlocking: split tests into separate files"
git push
```

# TESTING CHECKLIST

After fixing each template:

```bash
# Create fresh project
curl -X POST https://mwlhxwbkuumjxpnvldli.supabase.co/functions/v1/projects \
  -H "Content-Type: application/json" \
  -H "x-user-id: test-fix-$(date +%s)" \
  -d '{"moduleId":"stack","language":"Java"}' | jq -r .githubRepoUrl | xargs git clone

cd <cloned-repo>

# For Java:
mvn clean test

# For C++:
bash tests/run.sh

# Verify:
# - Only Challenge 1 compiles/runs
# - No compilation errors from locked tests
# - Test fails (because implementation is empty)
# - But it COMPILES successfully!
```

# PRIORITY ORDER

1. Java Stack (fastest to test)
2. Java Queue
3. Java Binary Search
4. Java Min Heap
5. C++ Stack
6. C++ Queue
7. C++ Binary Search
8. C++ Min Heap

# SUCCESS CRITERIA

‚úÖ Each template:
- Compiles with empty implementation (no errors from locked tests)
- Only runs unlocked tests
- Progressive unlocking works incrementally
- All changes pushed to GitHub

# IMPORTANT NOTES

1. **Test after EACH template** - don't fix all at once then test
2. **Java TestRunner needs MODULE_ID adjusted** for each template
3. **C++ run.sh needs MODULE_ID adjusted** for each template
4. **Keep file naming consistent**: Test##_Name.java or test_##_name.cpp
5. **Git commit after each template** with clear message

# START NOW

Begin with Java Stack template. Fix it, test it, push it. Then move to next template.

Report progress after each template is complete.

GO! üöÄ

