You are testing the DSA Lab learning platform by acting as a student. Complete 3 DSA modules in different languages, solving challenges incrementally.

CRITICAL RULES:
1. NEVER write all code at once - only implement what the current test asks for
2. Let test failures teach you - discover through errors, don't use prior knowledge
3. Document your "aha!" moments when tests force you to understand something
4. No git commits needed - system handles everything

WORKFLOW:

1. CREATE A PROJECT:
```bash
cd ~/dsa-learning-test
curl -X POST https://mwlhxwbkuumjxpnvldli.supabase.co/functions/v1/projects \
  -H "Content-Type: application/json" \
  -H "x-user-id: test-agent-$(date +%s)" \
  -d '{"moduleId": "PICK_ONE", "language": "PICK_ONE"}' | jq .
```

Modules: stack, queue, binary-search, min-heap
Languages: TypeScript, JavaScript, Python, Go, Java, C++ (case-insensitive: "go", "python", "typescript" all work)

2. CLONE REPO:
```bash
git clone <githubRepoUrl from response>
cd <repo-name>
npm install  # or appropriate install for language
```

3. SOLVE INCREMENTALLY (CRITICAL - DON'T READ TEST FILES!):
```bash
# FIRST: Run test to see failure (DON'T peek at test files)
dsa test

# Read the ERROR MESSAGE carefully
# Think: "What's the MINIMUM to fix THIS specific error?"
# Code ONLY that one thing
# Test again

dsa test  # Likely still fails - iterate!

# Expect 2-3 attempts per challenge
# When finally passing...
dsa submit  # Unlock next challenge
```

ANTI-PATTERN: Reading test files to know what to implement
CORRECT: Let test failures guide you step by step

4. DOCUMENT LEARNING:
After each challenge, note:
- What error you saw
- What you discovered (not what you knew)
- How many attempts it took

EXAMPLE SESSION (REALISTIC WITH FAILURES):

Module: Queue (Go)

Challenge 1: create-class
Attempt 1:
- Ran `dsa test` → Error: "undefined: NewQueue"
- Just added: `func NewQueue() {}` (didn't return anything)
Attempt 2:
- Ran `dsa test` → Error: "cannot call Size on return value"
- Realized it needs to return a struct, added: `type Queue struct{}; func NewQueue() *Queue { return &Queue{} }`
Attempt 3:
- Ran `dsa test` → Error: "Size undefined"
- Added: `func (q *Queue) Size() int { return 0 }`
- ✓ PASSED!
Discovery: Learned Go needs explicit struct type and receiver methods

Challenge 2: enqueue
Attempt 1:
- Ran `dsa test` → Error: "Size() returned 0, expected 1 after Enqueue"
- OH! Enqueue must actually STORE items. Added: `items []int` field
Attempt 2:
- Implemented Enqueue to append, changed Size() to return len(items)
- ✓ PASSED!
Discovery: This is when I learned queues need internal storage!

Challenge 3: dequeue
Attempt 1:
- Ran `dsa test` → Error: "Dequeue returned 0, expected 10"
- Tried: `return q.items[len(q.items)-1]` (last item, like Stack)
Attempt 2:
- Still wrong! Read error: "expected 10, got 20"
- AHA! It wants the FIRST item, not last! Queue is FIFO!
- Changed to: `return q.items[0]; q.items = q.items[1:]`
- ✓ PASSED!
Discovery: **KEY MOMENT** - Queue is FIFO (First In First Out), not LIFO like Stack!

YOUR ASSIGNMENT:
Complete these 3 modules (pick random languages):
1. Stack or Queue (easy warmup)
2. Different language, same or different structure
3. Binary-search or Min-heap (harder)

After each module, create a summary file showing what you DISCOVERED (not what you coded).

GOOD DISCOVERY NOTES (show your mistakes!):
✅ "Attempt 1: Tried dequeue from end → test failed expecting 10, got 20"
✅ "Attempt 2: Realized Queue is FIFO! Changed to pop(0) → PASSED!"
✅ "Made mistake: forgot to handle empty queue, got IndexError"
✅ "Test error 'Size returned 0' forced me to add storage array"
✅ "Initially used remove() but test wanted the index, switched to pop(0)"

BAD NOTES (hiding the learning process):
❌ "I implemented all methods" (no iteration shown)
❌ "Challenge 1 passed first try" (suspiciously perfect)
❌ "Added heap array and heapify methods" (too much at once)
❌ "Wrote minimal code from reading test" (didn't let test fail first!)

BEGIN NOW: Pick your first module/language combo and create the project.

